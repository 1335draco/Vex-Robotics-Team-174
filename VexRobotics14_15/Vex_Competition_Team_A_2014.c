#pragma config(Motor,  port3,           LeftMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port4,           RightMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           ArmMotor,      tmotorVex393, openLoop)
#pragma config(Motor,  port8,           LeftArmMotor,  tmotorVex393, openLoop)
#pragma config(Motor,  port9,           RightArmMotor, tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void driveMotors(int leftSpeed, int rightSpeed)
{
	motor[LeftMotor]   =  leftSpeed;      // up = CW
	motor[RightMotor]  =  -rightSpeed;    // up = CCW
}

void moveArm(int aSpeed) //ground to robot is postive, vice versa
{
	motor[ArmMotor] = aSpeed;
}

void moveArmTop(int aSpeed) //ground to robot is postive, vice versa
{
	motor[LeftArmMotor] = aSpeed;
	motor[RightArmMotor] = aSpeed;
}


void teleop()
{
	driveMotors(vexRT[Ch3], vexRT[Ch2]);

	int armSpeed = 0;
	if(vexRT[Btn5U])
	{
		armSpeed = 127;
	}
	else if(vexRT[Btn5D])
	{
		armSpeed = -127;
	}
	moveArm(armSpeed);

	if(vexRT[Btn6U])
	{
		armSpeed = 127;
	}
	else if(vexRT[Btn6D])
	{
		armSpeed = -127;
	}
	moveArmTop(armSpeed);


}

//anna = -40;
//julie = 5;

//void julie (int anna)
//{
//	driveMotors(anna,anna);

//	if(!(anna == 0) == (julie==5))
//	{
//		driveMotors(0,0);
//	}
//	else if(anna == -40)
//	{
//		driveMotors(40,40);
//	}
//	else
//	{
//		driveMotors(346543,02523452435);
//	}
//}


void checkSideAndGo(int isRight)
{
	driveMotors(127,127); //Straight
	wait1Msec(3200);
	driveMotors(0,0);
	wait1Msec(5);

	if(isRight ==1)
	{
		driveMotors(-110,110); //Turn Left
		wait1Msec(800);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,127); //Drive Forward
		wait1Msec(2150);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(-127,127); //Turn Left
		wait1Msec(1350);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,100); //Drive Forward
		wait1Msec(4000);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(-100,100); //Turn Left
		wait1Msec(1000);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,127); //Drive Forward
		wait1Msec(3000);
		driveMotors(0,0);
		wait1Msec(5);
	}
	else
	{
		driveMotors(120,-120); //Turn Right
		wait1Msec(1000);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,127); //Drive Forward
		wait1Msec(2200);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(120,-120); //Turn Right
		wait1Msec(1200);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,127); //Drive Forward
		wait1Msec(3000);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(120,-120); //Turn Left
		wait1Msec(2500);
		driveMotors(0,0);
		wait1Msec(5);

		driveMotors(127,127); //Drive Forward
		wait1Msec(3000);
		driveMotors(0,0);
		wait1Msec(5);
	}
}

void checkSideAndSwoop(int isRight)
{
	//Drive forwards
	driveMotors(70,70);
	wait1Msec(1000);
	driveMotors(0,0);
	wait1Msec(5);

	//Knock off starting cube
	moveArm(127);
	wait1Msec(1000);
	moveArm(0);
	wait1Msec(5);

	//Continue straight
	driveMotors(70,70);
	wait1Msec(800);
	driveMotors(0,0);
	wait1Msec(5);

	driveMotors(120,-120);
	wait1Msec(2600);
	driveMotors(0,0);
	wait1Msec(5);

	driveMotors(70,70);
	wait1Msec(1800);
	driveMotors(0,0);
	wait1Msec(5);

	driveMotors(-70,-70);
	wait1Msec(1000);
	driveMotors(0,0);
	wait1Msec(5);

}

void testTurn90()
{
	driveMotors(-120,120); //Turn Left
		wait1Msec(800);
		driveMotors(0,0);
		wait1Msec(5);
}

void pushTwoCubesAuton()
{
	  driveMotors(120,120); //Drive Straight
		wait1Msec(1600);
		driveMotors(0,0);
		wait1Msec(5);


	driveMotors(-120, 120); //Turn Left
		wait1Msec(1200);
		driveMotors(0,0);
		wait1Msec(5);


	  driveMotors(120,120); //Drive Straight
		wait1Msec(1600);
		driveMotors(0,0);
		wait1Msec(5);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................
  //checkSideAndGo(1);//1 is right
  checkSideAndSwoop(1);

	//pushTwoCubesAuton();

  //testTurn90();
	//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

	  // .....................................................................................
	  // Insert user code here. This is where you use the joystick values to update your motors, etc.
	  // .....................................................................................
		teleop();
	  //UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}
